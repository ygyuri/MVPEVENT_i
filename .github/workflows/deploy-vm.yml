name: Build and Deploy to VM

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Verify image assets
        run: |
          echo "ğŸ” Checking image assets..."
          echo "ğŸ“ Client directory structure:"
          ls -la client/ || echo "No client directory"
          echo "ğŸ“ Client public directory contents:"
          if [ -d "client/public/" ]; then
            ls -la client/public/ || echo "No public directory"
            echo "ğŸ“ Client logos directory contents:"
            if [ -d "client/public/logos/" ]; then
              ls -la client/public/logos/ || echo "No logos directory"
            else
              echo "âš ï¸ No logos directory in public/"
            fi
          else
            echo "âš ï¸ No public directory found"
          fi
          echo "ğŸ“ Server uploads directory contents:"
          ls -la server/uploads/ || echo "No uploads directory"
          echo "âœ… Image asset verification completed"
      - name: Build images (no push)
        run: docker compose -f docker-compose.prod.yml build

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: always() && needs.build.result == 'success'
    steps:
      - uses: actions/checkout@v4
      - name: Create production environment file
        run: |
          cat > .env.production << 'EOF'
          # Application Configuration
          NODE_ENV=${{ secrets.NODE_ENV }}
          SERVER_PORT=${{ secrets.SERVER_PORT }}
          FRONTEND_URL=${{ secrets.FRONTEND_URL }}
          BASE_URL=${{ secrets.BASE_URL }}
          
          # GKE Configuration
          KUBERNETES_NAMESPACE=${{ secrets.KUBERNETES_NAMESPACE }}
          GKE_CLUSTER_NAME=${{ secrets.GKE_CLUSTER_NAME }}
          GKE_ZONE=${{ secrets.GKE_ZONE }}
          PROJECT_ID=${{ secrets.PROJECT_ID }}
          
          # Nginx Configuration
          NGINX_HTTP_PORT=${{ secrets.NGINX_HTTP_PORT }}
          NGINX_HTTPS_PORT=${{ secrets.NGINX_HTTPS_PORT }}
          
          # Database Configuration
          MONGO_ROOT_USERNAME=${{ secrets.MONGO_ROOT_USERNAME }}
          MONGO_ROOT_PASSWORD=${{ secrets.MONGO_ROOT_PASSWORD }}
          MONGODB_URI=${{ secrets.MONGODB_URI }}
          
          # Redis Configuration
          REDIS_URL=${{ secrets.REDIS_URL }}
          
          # JWT Configuration
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          JWT_REFRESH_SECRET=${{ secrets.JWT_REFRESH_SECRET }}
          JWT_EXPIRES_IN=${{ secrets.JWT_EXPIRES_IN }}
          JWT_REFRESH_EXPIRES_IN=${{ secrets.JWT_REFRESH_EXPIRES_IN }}
          
          # PayHero Configuration
          PAYHERO_API_USERNAME=${{ secrets.PAYHERO_API_USERNAME }}
          PAYHERO_API_PASSWORD=${{ secrets.PAYHERO_API_PASSWORD }}
          PAYHERO_ACCOUNT_ID=${{ secrets.PAYHERO_ACCOUNT_ID }}
          PAYHERO_BASIC_AUTH_TOKEN=${{ secrets.PAYHERO_BASIC_AUTH_TOKEN }}
          PAYHERO_CHANNEL_ID=${{ secrets.PAYHERO_CHANNEL_ID }}
          PAYHERO_CALLBACK_URL=${{ secrets.PAYHERO_CALLBACK_URL }}
          PAYHERO_SUCCESS_URL=${{ secrets.PAYHERO_SUCCESS_URL }}
          PAYHERO_FAILED_URL=${{ secrets.PAYHERO_FAILED_URL }}
          
          # MPESA Configuration
          MPESA_BASE_URL=${{ secrets.MPESA_BASE_URL }}
          MPESA_CONSUMER_KEY=${{ secrets.MPESA_CONSUMER_KEY }}
          MPESA_CONSUMER_SECRET=${{ secrets.MPESA_CONSUMER_SECRET }}
          MPESA_PASSKEY=${{ secrets.MPESA_PASSKEY }}
          MPESA_SHORTCODE=${{ secrets.MPESA_SHORTCODE }}
          MPESA_CALLBACK_URL=${{ secrets.MPESA_CALLBACK_URL }}
          MPESA_TIMEOUT_URL=${{ secrets.MPESA_TIMEOUT_URL }}
          
          # Email Configuration
          SMTP_HOST=${{ secrets.SMTP_HOST }}
          SMTP_PORT=${{ secrets.SMTP_PORT }}
          SMTP_USER=${{ secrets.SMTP_USER }}
          SMTP_PASS=${{ secrets.SMTP_PASS }}
          EMAIL_FROM=${{ secrets.EMAIL_FROM }}
          
          # Security Configuration
          TICKET_QR_SECRET=${{ secrets.TICKET_QR_SECRET }}
          TICKET_QR_ENC_KEY=${{ secrets.TICKET_QR_ENC_KEY }}
          TICKET_QR_AUTO_ROTATE_MS=${{ secrets.TICKET_QR_AUTO_ROTATE_MS }}
          
          # Rate Limiting
          RATE_LIMIT_WINDOW_MS=${{ secrets.RATE_LIMIT_WINDOW_MS }}
          RATE_LIMIT_MAX_REQUESTS=${{ secrets.RATE_LIMIT_MAX_REQUESTS }}
          
          # Debug Configuration
          DEBUG=${{ secrets.DEBUG }}
          LOG_LEVEL=${{ secrets.LOG_LEVEL }}
          
          # Monitoring and Logging
          SENTRY_DSN=${{ secrets.SENTRY_DSN }}
          LOG_TO_FILE=${{ secrets.LOG_TO_FILE }}
          LOG_FILE_PATH=${{ secrets.LOG_FILE_PATH }}
          EOF
      - name: Transfer environment file to VM
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          source: ".env.production"
          target: "/tmp/.env.production"
      - name: SSH deploy to VM
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VM_HOST }}
          username: ${{ secrets.VM_USER }}
          key: ${{ secrets.VM_SSH_KEY }}
          script: |
            set -e
            cat > /tmp/deploy.sh << 'DEPLOYMENT_SCRIPT'
            set -e
            echo "ğŸš€ Starting deployment..."
              
              # Ensure repo exists and is up to date
              if [ -d /root/MVPEVENT_i/.git ]; then
                echo "ğŸ“ Repository exists, updating..."
                cd /root/MVPEVENT_i
                git remote set-url origin https://github.com/ygyuri/MVPEVENT_i.git
                git fetch --all
                git reset --hard origin/main
              else
                echo "ğŸ“ Cloning repository..."
                rm -rf /root/MVPEVENT_i || true
                git clone https://github.com/ygyuri/MVPEVENT_i.git /root/MVPEVENT_i
                cd /root/MVPEVENT_i
              fi
              
              # Show current commit
              echo "ğŸ“ Current commit: $(git log --oneline -1)"
              
              # Verify image assets are present
              echo "ğŸ” Verifying image assets..."
              echo "ğŸ“ Client directory structure:"
              ls -la /root/MVPEVENT_i/client/ || echo "No client directory"
              echo "ğŸ“ Client public directory contents:"
              if [ -d "/root/MVPEVENT_i/client/public/" ]; then
                ls -la /root/MVPEVENT_i/client/public/ || echo "No public directory"
                echo "ğŸ“ Client logos directory contents:"
                if [ -d "/root/MVPEVENT_i/client/public/logos/" ]; then
                  ls -la /root/MVPEVENT_i/client/public/logos/ || echo "No logos directory"
                else
                  echo "âš ï¸ No logos directory in public/"
                fi
              else
                echo "âš ï¸ No public directory found"
              fi
              echo "ğŸ“ Server uploads directory contents:"
              ls -la /root/MVPEVENT_i/server/uploads/ || echo "No uploads directory"
              echo "âœ… Image asset verification completed"
              
              # Move and secure environment file
              echo "ğŸ” Setting up environment file..."
              # Debug: Check what's in /tmp
              echo "ğŸ“‹ Contents of /tmp/.env.production:"
              ls -la /tmp/.env.production || echo "File not found"
              
              # Handle case where .env.production might be a directory
              if [ -d /tmp/.env.production ]; then
                echo "ğŸ“ Found directory, extracting file..."
                # Copy the file from the directory
                sudo cp /tmp/.env.production/.env.production /root/MVPEVENT_i/.env.production
                # Clean up the temporary directory
                sudo rm -rf /tmp/.env.production
              else
                echo "ğŸ“„ Found file, moving directly..."
                # Remove existing file/directory if it exists
                sudo rm -rf /root/MVPEVENT_i/.env.production || true
                # Move the new file
                sudo mv /tmp/.env.production /root/MVPEVENT_i/.env.production
              fi
              
              # Set proper permissions for Docker Compose access
              echo "ğŸ” Setting up permissions for Docker Compose..."
              
              # Make sure the directory is accessible
              sudo chmod 755 /root/MVPEVENT_i
              
              # Set permissions for .env.production (keep secure)
              sudo chown root:root /root/MVPEVENT_i/.env.production
              sudo chmod 600 /root/MVPEVENT_i/.env.production
              
              # Create .env file for docker compose (it looks for .env by default)
              echo "ğŸ“„ Creating .env file for docker compose..."
              echo "ğŸ“‹ Checking if .env.production exists:"
              sudo ls -la /root/MVPEVENT_i/.env.production || echo "âŒ .env.production not found"
              
              # Copy the file
              sudo cp /root/MVPEVENT_i/.env.production /root/MVPEVENT_i/.env
              echo "ğŸ“‹ Copy completed, setting permissions..."
              
              # Set permissions for .env file (Docker Compose needs to read this)
              sudo chown root:docker /root/MVPEVENT_i/.env
              sudo chmod 640 /root/MVPEVENT_i/.env
              
              # Verify the files were created correctly
              echo "ğŸ“‹ Environment files created successfully:"
              sudo ls -la /root/MVPEVENT_i/.env.production
              sudo ls -la /root/MVPEVENT_i/.env
              
              # Ensure we're in the correct directory for docker compose commands
              echo "ğŸ“ Current working directory: $(pwd)"
              echo "ğŸ“‹ Contents of current directory:"
              ls -la
              
              # Setup Let's Encrypt SSL certificates
              echo "ğŸ” Setting up Let's Encrypt SSL certificates..."
              
              # Install certbot if not already installed
              if ! command -v certbot &> /dev/null; then
                echo "ğŸ“¦ Installing certbot..."
                sudo apt update
                sudo apt install -y certbot
              fi
              
              # Stop nginx temporarily for certificate generation
              echo "ğŸ›‘ Temporarily stopping nginx for certificate generation..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml stop nginx || true
              
              # Generate Let's Encrypt certificate
              echo "ğŸ”‘ Generating Let's Encrypt certificate for event-i.co.ke..."
              sudo certbot certonly --standalone \
                --non-interactive \
                --agree-tos \
                --email admin@event-i.co.ke \
                -d event-i.co.ke \
                --force-renewal || echo "âš ï¸ Certificate generation failed, using existing certificates"
              
              # Copy certificates to nginx ssl directory
              echo "ğŸ“ Copying certificates to nginx ssl directory..."
              sudo mkdir -p /root/MVPEVENT_i/nginx/ssl
              sudo cp /etc/letsencrypt/live/event-i.co.ke/fullchain.pem /root/MVPEVENT_i/nginx/ssl/cert.pem || echo "âš ï¸ Using existing cert.pem"
              sudo cp /etc/letsencrypt/live/event-i.co.ke/privkey.pem /root/MVPEVENT_i/nginx/ssl/key.pem || echo "âš ï¸ Using existing key.pem"
              sudo chmod 644 /root/MVPEVENT_i/nginx/ssl/cert.pem
              sudo chmod 600 /root/MVPEVENT_i/nginx/ssl/key.pem
              
              echo "âœ… SSL certificates setup completed"
              
              # Debug: Show the actual environment file being used
              echo "ğŸ” Debug: Current environment file contents:"
              sudo cat /root/MVPEVENT_i/.env || echo "âŒ .env file not found"
              echo ""
              echo "ğŸ” Debug: Environment variables for Docker Compose:"
              echo "MONGODB_URI: mongodb://${{ secrets.MONGO_ROOT_USERNAME }}:${{ secrets.MONGO_ROOT_PASSWORD }}@mongodb:27017/event_i_production?authSource=admin"
              echo "REDIS_URL: redis://redis:6379"
              echo ""
              
              # Stop existing containers gracefully
              echo "ğŸ›‘ Stopping existing containers..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml down --remove-orphans || true
              
              # Clean up old images and containers to save space
              echo "ğŸ§¹ Cleaning up old Docker resources..."
              sudo docker container prune -f || true
              sudo docker image prune -f || true
              sudo docker volume prune -f || true
              
              # Pull latest base images to ensure we have the most recent versions
              echo "ğŸ“¥ Pulling latest base images..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml pull || true
              
              # Build with no cache and force pull to ensure fresh builds
              echo "ğŸ”¨ Building Docker images with fresh cache..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml build --no-cache --pull
              
              # Deploy with force recreate to ensure containers are restarted
              echo "ğŸš€ Deploying containers with force recreate..."
              
              # Create temporary environment file with Docker Compose service names
              echo "ğŸ”§ Creating temporary environment file with Docker Compose service names..."
              sudo cp /root/MVPEVENT_i/.env /root/MVPEVENT_i/.env.backup
              
              # Update the .env file to use Docker Compose service names
              MONGO_USER="${{ secrets.MONGO_ROOT_USERNAME }}"
              MONGO_PASS="${{ secrets.MONGO_ROOT_PASSWORD }}"
              # URL encode the password to handle special characters
              MONGO_PASS_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote(\"${MONGO_PASS}\"))")
              # Replace MongoDB URL with proper Docker Compose service name
              sudo sed -i "s|MONGODB_URI=.*|MONGODB_URI=mongodb://${MONGO_USER}:${MONGO_PASS_ENCODED}@mongodb:27017/event_i_production?authSource=admin|g" /root/MVPEVENT_i/.env
              # Replace Redis URL with Docker Compose service name
              sudo sed -i "s|REDIS_URL=.*|REDIS_URL=redis://redis:6379|g" /root/MVPEVENT_i/.env
              
              # Verify the changes
              echo "ğŸ” Updated environment file:"
              sudo grep -E "(MONGODB_URI|REDIS_URL)" /root/MVPEVENT_i/.env
              echo ""
              echo "ğŸ” Debug: MongoDB URL components:"
              echo "MONGO_USER: ${MONGO_USER}"
              echo "MONGO_PASS_ENCODED: ${MONGO_PASS_ENCODED}"
              echo "Final MongoDB URL: mongodb://${MONGO_USER}:${MONGO_PASS_ENCODED}@mongodb:27017/event_i_production?authSource=admin"
              
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml up -d --force-recreate --remove-orphans
              
              # Wait for services to start and perform health checks
              echo "â³ Waiting for services to start..."
              sleep 20
              
              # Debug: Check what environment variables the server container is using
              echo "ğŸ” Debug: Server container environment variables:"
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml exec server env | grep -E "(MONGODB_URI|REDIS_URL|NODE_ENV|PORT)" || echo "âŒ Could not get server environment"
              echo ""
              
              # Debug: Test connectivity from server to MongoDB and Redis
              echo "ğŸ” Debug: Testing connectivity from server container:"
              echo "Testing MongoDB connection..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml exec server nc -zv mongodb 27017 || echo "âŒ MongoDB connection failed"
              echo "Testing Redis connection..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml exec server nc -zv redis 6379 || echo "âŒ Redis connection failed"
              echo ""
              
              # Verify deployment status
              echo "âœ… Checking deployment status..."
              echo "ğŸ“ Current working directory: $(pwd)"
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml ps
              
              # Check container health status
              echo "ğŸ” Checking container health..."
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
              
              # Wait for containers to be healthy
              echo "â³ Waiting for containers to be healthy..."
              max_attempts=30
              attempt=1
              
              while [ $attempt -le $max_attempts ]; do
                echo "Health check attempt $attempt/$max_attempts..."
                
                # Check if all containers are running
                if sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml ps | grep -q "Up"; then
                  echo "âœ… All containers are running"
                  break
                else
                  echo "â³ Containers still starting..."
                  sleep 10
                  attempt=$((attempt + 1))
                fi
              done
              
              if [ $attempt -gt $max_attempts ]; then
                echo "âŒ Containers failed to start within timeout"
                echo "ğŸ“‹ Container logs:"
                sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs --tail=50
                exit 1
              fi
              
              # Test API health with retries
              echo "ğŸ” Testing API health..."
              api_healthy=false
              for i in {1..5}; do
                # Test both direct API endpoint and nginx health endpoint using production domain
                if curl -f -s -k https://event-i.co.ke/api/health > /dev/null 2>&1 || curl -f -s -k https://event-i.co.ke/health > /dev/null 2>&1; then
                  echo "âœ… API health check passed (attempt $i)"
                  api_healthy=true
                  break
                else
                  echo "â³ API health check attempt $i failed, retrying..."
                  sleep 5
                fi
              done
              
              if [ "$api_healthy" = false ]; then
                echo "âŒ API health check failed after 5 attempts"
                echo "ğŸ“‹ Testing individual components..."
                
                # Test nginx directly
                echo "ğŸ” Testing nginx container..."
                if sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml exec nginx curl -f -s http://localhost/health > /dev/null 2>&1; then
                  echo "âœ… Nginx health endpoint working"
                else
                  echo "âŒ Nginx health endpoint failed"
                fi
                
                # Test backend directly
                echo "ğŸ” Testing backend container..."
                if sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml exec server curl -f -s http://localhost:5000/api/health > /dev/null 2>&1; then
                  echo "âœ… Backend health endpoint working"
                else
                  echo "âŒ Backend health endpoint failed"
                fi
                
                echo "ğŸ“‹ Server logs:"
                sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs server --tail=50
                echo "ğŸ“‹ Nginx logs:"
                sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs nginx --tail=50
                exit 1
              fi
              
              # Test frontend accessibility with retries
              echo "ğŸ” Testing frontend accessibility..."
              frontend_healthy=false
              for i in {1..5}; do
                if curl -f -s -k https://event-i.co.ke/ > /dev/null 2>&1; then
                  echo "âœ… Frontend accessibility check passed (attempt $i)"
                  frontend_healthy=true
                  break
                else
                  echo "â³ Frontend accessibility check attempt $i failed, retrying..."
                  sleep 5
                fi
              done
              
              if [ "$frontend_healthy" = false ]; then
                echo "âŒ Frontend accessibility check failed after 5 attempts"
                echo "ğŸ“‹ Client logs:"
                sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs client --tail=50
                echo "ğŸ“‹ Nginx logs:"
                sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs nginx --tail=50
                exit 1
              fi
              
              # Run image verification script
              echo "ğŸ” Running image asset verification..."
              echo "ğŸ“ Checking scripts directory..."
              sudo ls -la /root/MVPEVENT_i/scripts/ || echo "No scripts directory found"
              
              if [ -f "/root/MVPEVENT_i/scripts/verify-images.sh" ]; then
                echo "ğŸ“„ Found verify-images.sh script"
                echo "ğŸ“‹ Current permissions:"
                sudo ls -la /root/MVPEVENT_i/scripts/verify-images.sh
                echo "ğŸ”§ Making script executable..."
                sudo chmod +x /root/MVPEVENT_i/scripts/verify-images.sh
                echo "ğŸ“‹ Updated permissions:"
                sudo ls -la /root/MVPEVENT_i/scripts/verify-images.sh
                echo "ğŸš€ Executing image verification script..."
                if sudo /root/MVPEVENT_i/scripts/verify-images.sh; then
                  echo "âœ… Image verification completed successfully"
                else
                  echo "âš ï¸ Image verification had warnings or failed, but continuing deployment"
                fi
              else
                echo "âš ï¸ verify-images.sh script not found, skipping verification"
                echo "ğŸ“ Available scripts in /root/MVPEVENT_i/scripts/:"
                sudo ls -la /root/MVPEVENT_i/scripts/ || echo "No scripts directory found"
              fi
              
              # Show deployment summary
              echo "ğŸ“Š Deployment Summary"
              echo "===================="
              echo "âœ… All containers rebuilt and restarted successfully"
              echo "âœ… API health check passed"
              echo "âœ… Frontend accessibility check passed"
              echo "âœ… Image assets verified"
              echo ""
              echo "ğŸ“‹ Container Status:"
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml ps --format "table {{.Name}}\t{{.Status}}\t{{.Ports}}"
              echo ""
              echo "ğŸ”— Service URLs:"
              echo "   Frontend: https://event-i.co.ke/"
              echo "   API:      https://event-i.co.ke/api/health"
              echo "   Health:   https://event-i.co.ke/health"
              echo "   Images:   https://event-i.co.ke/uploads/"
              echo ""
              echo "Recent logs (last 10 lines):"
              sudo docker compose -f /root/MVPEVENT_i/docker-compose.prod.yml logs --tail=10
              echo ""
              echo "Deployment completed successfully!"
            DEPLOYMENT_SCRIPT
            chmod +x /tmp/deploy.sh
            sudo bash /tmp/deploy.sh
            rm /tmp/deploy.sh
